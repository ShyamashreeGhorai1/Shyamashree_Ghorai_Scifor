# -*- coding: utf-8 -*-
"""Python_Shyamashree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J_HZYPot993qYIdc6dpw2-ALVi3L_A3E

**Bank System**
"""

# Bank System
class bank:
  def __init__(self, name, pin, bankbalance):
    self.name = name
    self.pin = pin
    self.bankbalance = bankbalance


  def deposit(self):
    balance = float(input("Enter the balance: "))
    self.bankbalance += balance
    print("Deposit balance is: ", balance)
    print("Total balance after deposit is: ", self.bankbalance)



  def withdrawal(self):
   balance = float(input("Enter the balance: "))
   if self.bankbalance >= balance:
     self.bankbalance -= balance
     print("Withdrawal balance is: ", balance)
     print("Total balance after withdrawal is: ",self.bankbalance)

   else:
     print("Balance is insufficient")


  def show_balance(self):
    print("Bank Balance is", self.bankbalance)

Customer1 = bank('shyamashree',103,1000)

Customer1.deposit()

Customer1.withdrawal()

Customer1.show_balance()

"""**Multiple Linear Regression Problem**"""

import io
from google.colab import files

uploaded = files.upload()

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

df = pd.read_csv("Housing.csv")

df.head()

df.isnull().sum()

df.duplicated().sum()

df.info()

df.describe()

df['mainroad'] = df['mainroad'].replace(['yes','no'],[1,0])
df['guestroom'] = df['guestroom'].replace(['yes','no'],[1,0])
df['basement'] = df['basement'].replace(['yes','no'],[1,0])
df['hotwaterheating'] = df['hotwaterheating'].replace(['yes','no'],[1,0])
df['airconditioning'] = df['airconditioning'].replace(['yes','no'],[1,0])
df['prefarea'] = df['prefarea'].replace(['yes','no'],[1,0])
df['furnishingstatus'] = df['furnishingstatus'].replace(['furnished','semi-furnished','unfurnished'],[2,1,0])

x = df.iloc[:,1:].values
y = df.iloc[:,0].values

# train test split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Adding a column for intercept term
x_train = np.insert(x_train,0,1,axis=1)
x_test = np.insert(x_test,0,1,axis=1)

def linearRegression(x, y, learning_rate, epochs):
  samples, features = x.shape
  weights = np.zeros(features)

  for epoch in range(epochs):
    predictions = np.dot(x, weights)
    gradient = 1/(samples)*np.sum(x.T*(predictions - y))
    weights -= learning_rate*gradient

  return weights

learning_rate = 0.000000000001
epochs = 100000
weights = linearRegression(x_train, y_train, learning_rate, epochs)

y_pred = np.dot(x_test, weights)

RMSE = np.sqrt(np.mean((y_pred - y_test)**2))
MSE = np.mean((y_pred-y_test)**2)
MAE = np.mean(np.abs((y_pred-y_test)))
R2 = 1 - (MSE/ np.sum((y_test - np.mean(y_test))**2))

print("Root-mean-square-error is:",RMSE)
print("Mean-square-error is:", MSE)
print("Mean-absolute-error is:",MAE)
print("R-squared error is:", R2)

import seaborn as sns
import matplotlib.pyplot as plt
sns.regplot(x=y_test, y=y_pred)
plt.xlabel('Actual Value')
plt.ylabel('Predicted Value')
plt.title('Actual Value vs Predicted Value')

"""**Simple Linear Regression Problem**"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

import io
from google.colab import files

uploaded = files.upload()

df = pd.read_csv("Salary_dataset.csv")

df.head()

df = df.drop(['Unnamed: 0'], axis=1)

df.isnull().sum()

df.duplicated().sum()

x = df['YearsExperience'].values

y = df['Salary'].values

x_train,x_test,y_train,y_test = train_test_split(x, y, test_size=0.2, random_state=42)

x_train = np.vstack((np.ones_like(x_train), x_train))
x_test = np.vstack((np.ones_like(x_test), x_test))

def linearRegression(x, y, learning_rate, epochs):
  samples, features = x.T.shape
  weights = np.zeros(features)

  for epoch in range(epochs):
    predictions = np.dot(x.T, weights)
    gradient = 1/(samples)*np.sum(x*(predictions - y))
    weights -= learning_rate*gradient

  return weights

learning_rate = 0.000000001
epochs = 1000
weights = linearRegression(x_train, y_train, learning_rate, epochs)

y_pred = np.dot(x_test.T, weights)

RMSE = np.sqrt(np.mean((y_pred - y_test)**2))
MSE = np.mean((y_pred-y_test)**2)
MAE = np.mean(np.abs((y_pred-y_test)))

print("Root-mean-square-error is:",RMSE)
print("Mean-square-error is:", MSE)
print("Mean-absolute-error is:",MAE)

"""**Polynomial Regression Problem**"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

import io
from google.colab import files

uploaded = files.upload()

df = pd.read_csv("Salary_dataset.csv")

df.drop(['Unnamed: 0'], axis=1,inplace=True)

df.head()

x = df.iloc[:,:-1].values
y = df.iloc[:,-1].values

# Fitting Polynomial Regression to the dataset
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

poly = PolynomialFeatures(degree=4)
x_poly = poly.fit_transform(x)

poly.fit(x_poly, y)
lin2 = LinearRegression()
lin2.fit(x_poly, y)

# Visualising the Polynomial Regression results
plt.scatter(x, y, color='blue')

plt.plot(x, lin2.predict(poly.fit_transform(x)),
         color='red')
plt.title('Polynomial Regression')
plt.xlabel('YearsExperience')
plt.ylabel('Salary')

plt.show()

"""**KNN Problem**"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

import io
from google.colab import files

uploaded = files.upload()

df = pd.read_csv("loan_data_set.csv")

df.head()

#Checking for missing values
df.isnull().sum()

#Filling Gender column by mode
df['Gender']=df['Gender'].fillna(df['Gender'].mode().values[0])
#Filling Married column by mode
df['Married']=df['Married'].fillna(df['Married'].mode().values[0])
#Filling Dependents column by mode
df['Dependents']=df['Dependents'].fillna(df['Dependents'].mode().values[0])
#Filling Self_Employed column by mode
df['Self_Employed']=df['Self_Employed'].fillna(df['Self_Employed'].mode().values[0])
#Filling LoanAmount column by mean
df['LoanAmount']=df['LoanAmount'].fillna(df['LoanAmount'].mean())
#Filling Loan_Amount_Term column by mode
df['Loan_Amount_Term']=df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mode().values[0] )
#Filling Credit_History column by mode
df['Credit_History']=df['Credit_History'].fillna(df['Credit_History'].mode().values[0] )

#Checking missing values after imputation
df.isna().sum()

#Dropping unnecessary columns
df.drop('Loan_ID', axis=1, inplace=True)

#Converting some object data type to int
gender = {"Female": 0, "Male": 1}
yes_no = {'No' : 0,'Yes' : 1}
dependents = {'0':0,'1':1,'2':2,'3+':3}
education = {'Not Graduate' : 0, 'Graduate' : 1}
property = {'Semiurban' : 0, 'Urban' : 1,'Rural' : 2}
output = {"N": 0, "Y": 1}
df['Gender'] = df['Gender'].replace(gender)
df['Married'] = df['Married'].replace(yes_no)
df['Dependents'] = df['Dependents'].replace(dependents)
df['Education'] = df['Education'].replace(education)
df['Self_Employed'] = df['Self_Employed'].replace(yes_no)
df['Property_Area'] = df['Property_Area'].replace(property)
df['Loan_Status'] = df['Loan_Status'].replace(output)

df.head()

#Setting the value for dependent and independent variables
x = df.drop('Loan_Status', 1)
y = df.Loan_Status

#Splitting the dataset
from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test= train_test_split(x, y, test_size= 0.25, random_state=38, stratify = y)

#Fitting the KNN model
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors = 5)
knn.fit(X_train, Y_train)

#Fitting the KNN model
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors = 5)
knn.fit(X_train, Y_train)

#Prediction of test set
prediction_knn = knn.predict(X_test)
#Print the predicted values
print("Prediction for test set: {}".format(prediction_knn))

#Actual value and the predicted value
a = pd.DataFrame({'Actual value': Y_test, 'Predicted value': prediction_knn})
a.head()

#Confusion matrix and classification report
from sklearn import metrics
import seaborn as sns
from sklearn.metrics import classification_report, confusion_matrix
matrix = confusion_matrix(Y_test, prediction_knn)
sns.heatmap(matrix, annot=True, fmt="d")
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('True')
print(classification_report(Y_test, prediction_knn))





